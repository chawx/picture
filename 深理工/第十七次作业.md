# 第十七次作业



![](https://raw.githubusercontent.com/chawx/picture/main/imageSnipaste_2023-12-01_15-32-39.png)







1. **移除安全检查，允许任意数据：** 在`main`函数的第 68 行，有一个检查 `id >= MAX_ROWS`，你可以注释掉它，这样就可以传入任意的记录序号了。

   ```c
   // 注释掉检查
   // if(id >= MAX_ROWS) die("There's not that many records.");
   ```

2. **弄乱数据文件：** 打开数据文件并随机修改几个字节，这样可以破坏数据文件的完整性。这将导致在读取时出现问题。

3. **传递非法参数：** 尝试在命令行中以非法的方式传递参数，例如将文件参数放到动作后面。这可能导致程序执行不正确的动作或创建了一个以动作命名的文件。

4. **修复strncpy的bug：** 在`Database_set`函数中使用`strncpy`时，确保将最后一个字符设置为`\0`，以防止缓冲区溢出。这是因为`strncpy`不会在目标缓冲区末尾添加`\0`，如果源字符串长度超过目标缓冲区，目标缓冲区将不会以`\0`结尾。

   ```c
   // 修复strncpy的bug
   strncpy(addr->name, name, MAX_DATA - 1);
   addr->name[MAX_DATA - 1] = '\0';
   
   strncpy(addr->email, email, MAX_DATA - 1);
   addr->email[MAX_DATA - 1] = '\0';
   ```

5. **传递参数创建任意大小的数据库：** 这是一个相对复杂的任务。你需要修改程序，以接受用户传递的参数来动态分配数据库的大小。你可以使用`malloc`来分配数据库的内存，而不是使用固定大小的数组。这涉及到对代码的大量修改，包括动态分配内存、处理错误等。请注意，这可能导致程序对系统资源的需求增加，因此需要谨慎处理。







### 修改`die`函数以接收`conn`参数：

```c
codevoid die(const char *message, struct Connection *conn, int max_data, int max_rows)
{
    if(errno) {
        perror(message);
    } else {
        printf("ERROR: %s\n", message);
    }

    if (conn) {
        Database_close(conn);
    }

    printf("Max Data: %d, Max Rows: %d\n", max_data, max_rows);

    exit(1);
}
```

### 修改`Database_open`函数：

```c
codestruct Connection *Database_open(const char *filename, char mode, int max_data, int max_rows)
{
    struct Connection *conn = malloc(sizeof(struct Connection));
    if(!conn) die("Memory error", NULL, max_data, max_rows);

    conn->db = malloc(sizeof(struct Database));
    if(!conn->db) die("Memory error", conn, max_data, max_rows);

    conn->db->max_data = max_data;
    conn->db->max_rows = max_rows;

    if(mode == 'c') {
        conn->file = fopen(filename, "w");
    } else {
        conn->file = fopen(filename, "r+");

        if(conn->file) {
            Database_load(conn);
        }
    }

    if(!conn->file) die("Failed to open the file", conn, max_data, max_rows);

    return conn;
}
```

### 支持任意大小的数据库：

修改`struct Database`，并在`Database_open`中设置`max_data`和`max_rows`：

```c
#define MAX_DATA 512
#define MAX_ROWS 100

struct Database {
    int max_data;
    int max_rows;
    struct Address rows[MAX_ROWS];
};
```

### 添加`find`操作：

```c
codevoid Database_find(struct Connection *conn, const char *search)
{
    int i;
    struct Database *db = conn->db;

    for(i = 0; i < db->max_rows; i++) {
        struct Address *cur = &db->rows[i];

        if (cur->set && (strstr(cur->name, search) || strstr(cur->email, search))) {
            Address_print(cur);
        }
    }
}
```

### 重新计算文件大小：

修改`Database_write`函数，使之仅写入有效的数据部分，而不是整个结构体大小：

```c
codevoid Database_write(struct Connection *conn)
{
    rewind(conn->file);

    int rc = fwrite(conn->db, sizeof(struct Database), 1, conn->file);
    if(rc != 1) die("Failed to write database.", conn, conn->db->max_data, conn->db->max_rows);

    rc = fflush(conn->file);
    if(rc == -1) die("Cannot flush database.", conn, conn->db->max_data, conn->db->max_rows);
}
```

### 向`Address`添加可搜索字段：

```c
codestruct Address {
    int id;
    int set;
    char name[MAX_DATA];
    char email[MAX_DATA];
    char city[MAX_DATA];  // 新增字段
};
```

### 编写自动化测试脚本：

```c
bashCopy code#!/bin/bash

set -e

# Compile the program
gcc -o ex17 ex17.c

./ex17 test.db c
./ex17 test.db s 1 John john@example.com
./ex17 test.db s 2 Jane jane@example.com
./ex17 test.db l
./ex17 test.db g 1
./ex17 test.db g 2
./ex17 test.db find example
./ex17 test.db d 1
./ex17 test.db l

# Clean up
rm test.db
```

### 使用单一全局变量储存数据库连接：

```c
cCopy codestruct Connection {
    FILE *file;
    struct Database *db;
};

struct Connection global_conn;  // 全局变量

int main(int argc, char *argv[])
{
    if(argc < 3) die("USAGE: ex17 <dbfile> <action> [action params]");

    char *filename = argv[1];
    char action = argv[2][0];
    
    // 使用全局变量
    struct Connection *conn = &global_conn;
    *conn = Database_open(filename, action, MAX_DATA, MAX_ROWS);

    // ...

    Database_close(conn);

    return 0;
}
```

### 搜索“栈数据结构”：

在C语言中，栈数据结构通常通过数组和指针来实现。以下是一个简单的例子：

```c
cCopy code#define MAX_STACK_SIZE 100

struct Stack {
    int data[MAX_STACK_SIZE];
    int top;
};

void stack_push(struct Stack *stack, int value)
{
    if (stack->top < MAX_STACK_SIZE) {
        stack->data[stack->top++] = value;
    } else {
        printf("Stack overflow\n");
    }
}

int stack_pop(struct Stack *stack)
{
    if (stack->top > 0) {
        return stack->data[--stack->top];
    } else {
        printf("Stack underflow\n");
        return -1;  // 或者采取其他处理方式
    }
}

int stack_peek(struct Stack *stack)
{
    if (stack->top > 0) {
        return stack->data[stack->top - 1];
    } else {
        printf("Stack is empty\n");
        return -1;  // 或者采取其他处理方式
    }
}

int main()
{
    struct Stack myStack = { .top = 0 };

    stack_push(&myStack, 10);
    stack_push(&myStack, 20);

    printf("Peek: %d\n", stack_peek(&myStack));

    printf("Pop: %d\n", stack_pop(&myStack));
    printf("Pop: %d\n", stack_pop(&myStack));

    return 0;
}
```